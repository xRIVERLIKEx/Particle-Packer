<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Particle Pack Generator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load JSZip library for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* NEW CSS for the background */
        body {
            background-image: url('ParticleBG.gif');
            background-attachment: fixed; /* Makes it not scroll */
            background-size: cover; /* Stretches to fill the screen */
            background-position: center;
        }

        /* Custom styles for dark mode file inputs */
        input[type="file"]::file-selector-button {
            @apply bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors duration-200;
        }
        input[type="file"] {
            @apply text-gray-300;
        }
        /* Style for the copyable command block */
        #command-output {
            @apply bg-gray-900 text-green-400 p-4 rounded-lg font-mono relative;
        }
        #copy-button {
            @apply absolute top-2 right-2 bg-gray-700 hover:bg-gray-600 text-white py-1 px-3 rounded-lg text-sm;
        }
    </style>
</head>
<body class="text-white font-sans p-6 md:p-12"> <!-- Removed bg-gray-900 from class list -->

    <!-- Added transparency and backdrop blur to see the background through the card -->
    <div class="max-w-3xl mx-auto bg-gray-800/80 backdrop-blur-md rounded-2xl shadow-2xl p-8 md:p-10">
        
        <header class="text-center mb-8">
            <!-- ADDED IMAGE HERE -->
            <img src="Cleverlike School Header Image.png" alt="Cleverlike School Header" class="mx-auto mb-6" style="max-height: 90px;">
            
            <h1 class="text-4xl font-bold text-green-400 mb-2">Particle Pack Generator</h1>
            <p class="text-xl text-gray-300">For Minecraft Bedrock & Education</p>
        </header>

        <!-- Main Form -->
        <div class="space-y-8">

            <!-- Step 1: Pack Details -->
            <section id="step-1" class="space-y-4">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2">Step 1: Pack Details</h2>
                <div>
                    <label for="pack-name" class="block text-sm font-medium text-gray-300 mb-2">Pack Name</label>
                    <input type="text" id="pack-name" placeholder="e.g., My Awesome Particles" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </div>
                <div>
                    <label for="pack-desc" class="block text-sm font-medium text-gray-300 mb-2">Pack Description</label>
                    <input type="text" id="pack-desc" placeholder="A pack full of awesome particles" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </div>
                <!-- New Pack Icon Uploader -->
                <div>
                    <label for="pack-icon" class="block text-sm font-medium text-gray-300 mb-2">Pack Icon (Optional)</label>
                    <input type="file" id="pack-icon" accept="image/png" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3">
                    <p id="pack-icon-feedback" class="text-sm text-green-400 mt-2 hidden"></p>
                </div>
            </section>

            <!-- List of Added Particles -->
            <section id="particle-list-section" class="hidden">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2 mb-4">Added Particles</h2>
                <div id="particle-list-container" class="space-y-2 bg-gray-700 p-4 rounded-lg">
                    <!-- Added particles will be listed here -->
                </div>
            </section>

            <!-- Step 2: Snowstorm File -->
            <section id="step-2" class="space-y-4">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2">Step 2: Upload Snowstorm .json File</h2>
                <div>
                    <label for="json-file-input" class="block text-sm font-medium text-gray-300 mb-2">Select your particle's .json file:</label>
                    <input type="file" id="json-file-input" accept=".json" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3">
                </div>
            </section>

            <!-- Step 3: Textures (Dynamically populated) -->
            <section id="step-3" class="hidden space-y-4">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2">Step 3: Upload Required Textures</h2>
                <p class="text-gray-400">The app detected the following textures are needed. Please upload a <span class="font-bold text-yellow-400">.png</span> for each one.</p>
                <div id="texture-uploads-container" class="space-y-5 bg-gray-700 p-6 rounded-lg">
                    <!-- Texture inputs will be added here by JS -->
                </div>
            </section>

            <!-- Step 4: Add Particle Button -->
            <section id="step-add-particle" class="hidden">
                <button id="add-particle-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white text-lg font-bold py-3 px-6 rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                    Add Particle to Pack
                </button>
            </section>

            <!-- Step 5: Generate -->
            <section id="step-generate" class="hidden">
                <button id="generate-button" class="w-full bg-green-600 hover:bg-green-700 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105">
                    Generate Pack with Added Particles
                </button>
                <div id="error-message" class="text-red-400 text-center mt-4 font-medium"></div>
            </section>

            <!-- Step 6: Download & Command (Dynamically populated) -->
            <section id="step-download" class="hidden space-y-6 text-center">
                <h2 class="text-3xl font-semibold text-green-400">Pack Generated Successfully!</h2>
                
                <!-- Download Button -->
                <div>
                    <a id="download-link" class="inline-block bg-blue-600 hover:bg-blue-700 text-white text-xl font-bold py-4 px-8 rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105">
                        Download .mcpack
                    </a>
                </div>

                <!-- Command Output -->
                <div>
                    <h3 classs="text-xl font-semibold mb-2">Your Particle Commands:</h3>
                    <p class="text-gray-400 mb-2">Use these commands in-game to spawn your particles. Click to copy.</p>
                    <div id="command-output">
                        <button id="copy-button" title="Copy to clipboard">Copy</button>
                        <pre><code id="command-text" class="whitespace-pre-wrap"></code></pre>
                    </div>
                </div>
            </section>

        </div>
    </div>

    <script type="module">
        // --- Global State ---
        let particleQueue = []; // Stores all added particle data
        let allUploadedTextures = new Map(); // Global map of "textures/path.png" -> File object
        let packIconFile = null; // To store the optional pack_icon.png

        // --- Current Particle State (Temporary) ---
        let currentJson = null;
        let currentOriginalFileName = 'particle.json';
        let currentRequiredTextures = new Set();
        let currentNewTexturesToUpload = new Set();

        // --- DOM Elements ---
        const packNameInput = document.getElementById('pack-name');
        const packDescInput = document.getElementById('pack-desc');
        const packIconInput = document.getElementById('pack-icon'); // Icon input
        const packIconFeedback = document.getElementById('pack-icon-feedback'); // Icon feedback
        const jsonFileInput = document.getElementById('json-file-input');
        
        const particleListSection = document.getElementById('particle-list-section');
        const particleListContainer = document.getElementById('particle-list-container');
        
        const step3Section = document.getElementById('step-3');
        const textureUploadsContainer = document.getElementById('texture-uploads-container');
        
        const stepAddParticle = document.getElementById('step-add-particle');
        const addParticleButton = document.getElementById('add-particle-button');
        
        const stepGenerate = document.getElementById('step-generate');
        const generateButton = document.getElementById('generate-button');
        const errorMessage = document.getElementById('error-message');
        
        const stepDownload = document.getElementById('step-download');
        const downloadLink = document.getElementById('download-link');
        const commandText = document.getElementById('command-text');
        const copyButton = document.getElementById('copy-button');

        // --- Helper Functions ---
        
        /**
         * Generates a random UUID (v4).
         * Required for all manifest.json files.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Stores the uploaded pack icon file.
         */
        function handlePackIconUpload(event) {
            const file = event.target.files[0];
            if (file) {
                packIconFile = file;
                packIconFeedback.textContent = `✅ Icon selected: ${file.name}`;
                packIconFeedback.classList.remove('hidden');
            } else {
                packIconFile = null;
                packIconFeedback.classList.add('hidden');
            }
        }

        /**
         * Displays an error message to the user.
         */
        function showError(message) {
            errorMessage.textContent = message;
            // Clear the error after 5 seconds
            setTimeout(() => { errorMessage.textContent = ''; }, 5000);
        }

        /**
         * Checks if the *current* particle is valid and ready to be added.
         */
        function validateCurrentParticleState() {
            const jsonValid = currentJson !== null;
            
            // Check if all *new* textures for *this* particle are uploaded
            let newTexturesReady = true;
            for (const path of currentNewTexturesToUpload) {
                if (!allUploadedTextures.has(path)) {
                    newTexturesReady = false;
                    break;
                }
            }

            if (jsonValid && newTexturesReady) {
                addParticleButton.disabled = false;
                errorMessage.textContent = '';
            } else {
                addParticleButton.disabled = true;
            }
        }

        /**
         * Checks if the final pack is ready to be generated.
         */
        function validatePackState() {
            const nameValid = packNameInput.value.trim() !== '';
            const descValid = packDescInput.value.trim() !== '';
            const particlesAdded = particleQueue.length > 0;

            if (nameValid && descValid && particlesAdded) {
                stepGenerate.classList.remove('hidden');
            } else {
                stepGenerate.classList.add('hidden');
            }
        }


        /**
         * Parses the Snowstorm JSON file content.
         */
        function handleJsonFile(event) {
            const file = event.target.files[0];
            if (!file) {
                resetCurrentParticle();
                return;
            }

            currentOriginalFileName = file.name;
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const jsonString = e.target.result;
                    let tempJson = JSON.parse(jsonString); // Parse once to validate
                    
                    // Basic validation for Snowstorm file
                    if (!tempJson.particle_effect || !tempJson.particle_effect.description) {
                        throw new Error("This doesn't look like a valid Snowstorm JSON file.");
                    }
                    
                    // --- NEW LOGIC: Unique Texture Renaming ---
                    // 1. Get a unique prefix from the filename
                    const particlePrefix = currentOriginalFileName
                        .replace(/.json$/i, '') // remove .json
                        .replace(/[^a-z0-9]/gi, '_'); // sanitize

                    // 2. Find all original texture paths
                    const textureRegex = /"(textures\/[^"]+)"/g;
                    const matches = jsonString.match(textureRegex) || [];
                    const originalPaths = new Set(matches.map(path => path.substring(1, path.length - 1)));

                    let modifiedJsonString = jsonString;
                    currentRequiredTextures.clear(); // This will store the *new* paths

                    // 3. Create new paths and replace them in the string
                    originalPaths.forEach(originalPath => {
                        const pathParts = originalPath.split('/');
                        const fileName = pathParts.pop(); // e.g., "flame.png"
                        
                        // Create a new unique filename
                        const newFileName = `${particlePrefix}_${fileName}`; 
                        
                        // Create a new path. Let's put them in a 'particles' subfolder
                        // "textures/particles/my_particle_flame.png"
                        const newPath = `textures/particles/${newFileName}`; 
                        
                        // Add this *new* path to the list of required textures for this particle
                        currentRequiredTextures.add(newPath);

                        // Replace all instances of the old path *in the string* with the new one
                        // Use a regex to safely replace only the quoted string
                        modifiedJsonString = modifiedJsonString.replace(new RegExp(`"${originalPath}"`, 'g'), `"${newPath}"`);
                    });

                    // 4. Re-parse the JSON with the *modified* paths
                    currentJson = JSON.parse(modifiedJsonString);
                    // --- END NEW LOGIC ---

                    // Figure out which textures are *new*
                    currentNewTexturesToUpload.clear();
                    currentRequiredTextures.forEach(path => {
                        // Since paths are now unique (e.g., "textures/particles/particle1_flame.png"),
                        // this check will correctly see them as new.
                        if (!allUploadedTextures.has(path)) {
                            currentNewTexturesToUpload.add(path);
                        }
                    });

                    // Render the texture upload inputs
                    renderTextureInputs();
                    validateCurrentParticleState();

                } catch (err) {
                    showError("Error parsing JSON file: " + err.message);
                    resetCurrentParticle();
                }
            };

            reader.onerror = () => {
                showError("Failed to read the file.");
                resetCurrentParticle();
            };

            reader.readAsText(file);
        }

        /**
         * Creates and displays file input fields for *only* new, un-uploaded textures.
         */
        function renderTextureInputs() {
            textureUploadsContainer.innerHTML = ''; // Clear previous inputs
            
            if (currentNewTexturesToUpload.size === 0 && currentJson) {
                // This particle uses no *new* textures
                textureUploadsContainer.innerHTML = '<p class="text-gray-300 font-medium text-center">This particle uses textures you have already provided.</p>';
                step3Section.classList.remove('hidden');
                stepAddParticle.classList.remove('hidden');
            } else if (currentNewTexturesToUpload.size > 0) {
                currentNewTexturesToUpload.forEach(path => {
                    const inputId = `texture-input-${path.replace(/[\/\.]/g, '-')}`;
                    
                    const container = document.createElement('div');
                    container.className = "border-b border-gray-600 pb-4";
                    
                    const label = document.createElement('label');
                    label.htmlFor = inputId;
                    label.className = "block text-sm font-medium text-gray-300 mb-2";
                    label.textContent = `Required Path: ${path}`;
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.id = inputId;
                    input.accept = 'image/png'; // Only allow PNGs as they are standard
                    input.className = 'w-full bg-gray-600 border border-gray-500 rounded-lg p-2';
                    
                    // Store the required path in the input's dataset
                    input.dataset.path = path;
                    
                    input.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            allUploadedTextures.set(path, file); // Add to GLOBAL map
                            // Add a visual cue
                            label.textContent = `✅ ${path} (Uploaded: ${file.name})`;
                            label.classList.add('text-green-400');
                            // Remove this input from the "needed" set for validation
                            currentNewTexturesToUpload.delete(path);
                        } else {
                            allUploadedTextures.delete(path); // Remove from GLOBAL map
                            label.textContent = `Required Path: ${path}`;
                            label.classList.remove('text-green-400');
                            currentNewTexturesToUpload.add(path); // Re-add to "needed" set
                        }
                        validateCurrentParticleState();
                    });
                    
                    container.appendChild(label);
                    container.appendChild(input);
                    textureUploadsContainer.appendChild(container);
                });
                step3Section.classList.remove('hidden');
                stepAddParticle.classList.remove('hidden');
            } else {
                step3Section.classList.add('hidden');
                stepAddParticle.classList.add('hidden');
            }
        }

        /**
         * Resets the "current particle" UI to add another one.
         */
        function resetCurrentParticle() {
            currentJson = null;
            currentOriginalFileName = 'particle.json';
            currentRequiredTextures.clear();
            currentNewTexturesToUpload.clear();

            jsonFileInput.value = ''; // Clear file input
            step3Section.classList.add('hidden');
            textureUploadsContainer.innerHTML = '';
            stepAddParticle.classList.add('hidden');
            addParticleButton.disabled = true;
        }

        /**
         * Updates the list of added particles shown to the user.
         */
        function updateParticleListUI() {
            particleListContainer.innerHTML = ''; // Clear list
            if (particleQueue.length === 0) {
                particleListSection.classList.add('hidden');
                return;
            }

            particleQueue.forEach((particle, index) => {
                const item = document.createElement('div');
                item.className = "text-green-300";
                item.textContent = `Particle ${index + 1}: ${particle.identifier} (from ${particle.originalFileName})`;
                particleListContainer.appendChild(item);
            });
            particleListSection.classList.remove('hidden');
        }

        /**
         * Adds the fully-defined "current" particle to the main pack queue.
         */
        function handleAddParticleClick() {
            if (addParticleButton.disabled || !currentJson) return;

            // Add to queue
            particleQueue.push({
                json: currentJson,
                originalFileName: currentOriginalFileName,
                identifier: currentJson.particle_effect.description.identifier
            });

            // Update UI
            updateParticleListUI();
            resetCurrentParticle();
            validatePackState(); // Check if we can enable the final "Generate" button
        }

        /**
         * Creates the manifest.json file content.
         */
        function createManifest(name, desc, uuid1, uuid2) {
            // This function had a syntax error. It's now fixed.
            return {
                "format_version": 2,
                "header": {
                    "name": name,
                    "description": desc,
                    "uuid": uuid1,
                    "version": [1, 0, 0],
                    "min_engine_version": [1, 16, 0] // Common base version
                },
                "modules": [
                    {
                        "type": "resources", // Correct type for resource packs
                        "uuid": uuid2,
                        "version": [1, 0, 0]
                    }
                ]
            };
        }

        /**
         * Main function to generate the .mcpack file.
         */
        async function handleGenerateClick() {
            // Re-validate just in case
            if (particleQueue.length === 0) {
                showError("Please add at least one particle first.");
                return;
            }
            if (packNameInput.value.trim() === '' || packDescInput.value.trim() === '') {
                showError("Please provide a Pack Name and Description.");
                return;
            }

            try {
                const zip = new JSZip();
                const packName = packNameInput.value.trim();
                const packDesc = packDescInput.value.trim();
                const uuid1 = generateUUID();
                const uuid2 = generateUUID();

                // 1. Create and add manifest.json
                const manifest = createManifest(packName, packDesc, uuid1, uuid2);
                zip.file("manifest.json", JSON.stringify(manifest, null, 2));

                // Add pack_icon.png if it exists
                if (packIconFile) {
                    zip.file("pack_icon.png", packIconFile);
                }

                // 2. Add all particle JSON files
                for (const particle of particleQueue) {
                    zip.file(`particles/${particle.originalFileName}`, JSON.stringify(particle.json, null, 2));
                }

                // 3. Add all unique, uploaded textures
                for (const [path, file] of allUploadedTextures.entries()) {
                    // JSZip automatically creates folders from the path
                    zip.file(path, file);
                }

                // 4. Generate the zip file as a blob
                const blob = await zip.generateAsync({ type: "blob" });

                // 5. Create download link
                const url = URL.createObjectURL(blob);
                downloadLink.href = url;
                // Sanitize pack name for use in filename
                const safeFileName = packName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                downloadLink.download = `${safeFileName}.mcpack`;
                
                // 6. Show all particle commands
                const commands = particleQueue.map(p => `/particle ${p.identifier} ~ ~1 ~`).join('\n');
                commandText.textContent = commands;
                
                // 7. Show the final section
                stepDownload.classList.remove('hidden');

            } catch (err) {
                showError("An error occurred during pack generation: " + err.message);
                console.error(err);
            }
        }
        
        /**
         * Copies the generated command to the clipboard.
         */
        function copyCommandToClipboard() {
            // Use a temporary textarea for broad compatibility
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = commandText.textContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            try {
                document.execCommand('copy');
                // Give user feedback
                copyButton.textContent = 'Copied!';
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(tempTextArea);
        }

        // --- Event Listeners ---
        jsonFileInput.addEventListener('change', handleJsonFile);
        packNameInput.addEventListener('input', validatePackState);
        packDescInput.addEventListener('input', validatePackState);
        packIconInput.addEventListener('change', handlePackIconUpload); // Listener for icon
        
        addParticleButton.addEventListener('click', handleAddParticleClick);
        generateButton.addEventListener('click', handleGenerateClick);
        copyButton.addEventListener('click', copyCommandToClipboard);

        // Initial validation checks
        validatePackState();
        validateCurrentParticleState();

    </script>
</body>
</html>
